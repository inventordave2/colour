<xaiArtifact artifact_id="5fbc63dd-0572-463f-80a3-020c47591b4a" artifact_version_id="b5bffb97-0a80-4bd1-b963-8073c363e654" title="console_graphics_engine.c" contentType="text/x-csrc">
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#else
#include <unistd.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#endif

// Define constants
#define MAX_WIDTH 80
#define MAX_HEIGHT 24
#define PIXEL_HEIGHT (MAX_HEIGHT * 2)  // For bitmap mode, using half-blocks

// Color enums (basic 16 colors)
typedef enum {
    COLOR_BLACK = 0, COLOR_RED, COLOR_GREEN, COLOR_YELLOW,
    COLOR_BLUE, COLOR_MAGENTA, COLOR_CYAN, COLOR_WHITE,
    COLOR_BRIGHT_BLACK, COLOR_BRIGHT_RED, COLOR_BRIGHT_GREEN, COLOR_BRIGHT_YELLOW,
    COLOR_BRIGHT_BLUE, COLOR_BRIGHT_MAGENTA, COLOR_BRIGHT_CYAN, COLOR_BRIGHT_WHITE
} Color;

// Screen buffer for text mode: char and attributes
typedef struct {
    char ch;
    Color fg;
    Color bg;
    int dirty;  // Flag if changed
} Cell;

Cell text_buffer[MAX_HEIGHT][MAX_WIDTH];

// Pixel buffer for bitmap mode: 0-15 color, or -1 for transparent/off
int pixel_buffer[PIXEL_HEIGHT][MAX_WIDTH];

// Mode flag
int is_bitmap_mode = 0;

// Platform-specific handles
#ifdef _WIN32
HANDLE hConsole;
HANDLE hConsoleIn;
#else
struct termios orig_termios;
#endif

// Mouse event structure
typedef struct {
    int x;        // Console X (or pixel X in bitmap mode)
    int y;        // Console Y (or pixel Y in bitmap mode)
    int button;   // 0=none, 1=left, 2=right
    int is_click; // 1=click, 0=motion
} MouseEvent;

// Box structure
typedef struct {
    int x, y;     // Top-left corner
    int width, height; // Dimensions
} ConsoleBox;

// Non-Windows kbhit equivalent
#ifndef _WIN32
int kbhit(void) {
    struct timeval tv = {0, 0};
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv);
    return FD_ISSET(STDIN_FILENO, &fds);
}

// Non-Windows getch equivalent
int getch(void) {
    struct termios oldattr, newattr;
    int ch;
    tcgetattr(STDIN_FILENO, &oldattr);
    newattr = oldattr;
    newattr.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
    ch = getchar();
    tcsetattr(STDIN_FILENO, TCSANOW, &oldattr);
    return ch;
}
#endif

// Initialize console
void init_console() {
#ifdef _WIN32
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    hConsoleIn = GetStdHandle(STD_INPUT_HANDLE);
    // Enable ANSI escape codes and mouse input
    DWORD dwMode = 0;
    GetConsoleMode(hConsole, &dwMode);
    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_MOUSE_INPUT;
    SetConsoleMode(hConsole, dwMode);
#else
    tcgetattr(STDIN_FILENO, &orig_termios);
    struct termios raw = orig_termios;
    raw.c_lflag &= ~(ECHO | ICANON);
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
    // Enable mouse tracking (xterm-compatible)
    printf("\033[?1000;1006h");
#endif
    // Clear buffers
    memset(text_buffer, 0, sizeof(text_buffer));
    memset(pixel_buffer, -1, sizeof(pixel_buffer));
    clear_screen();
}

// Cleanup console
void cleanup_console() {
#ifndef _WIN32
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
    printf("\033[?1000;1006l"); // Disable mouse tracking
#endif
}

// Clear screen
void clear_screen() {
#ifdef _WIN32
    system("cls");
#else
    printf("\033[2J");
#endif
    for (int y = 0; y < MAX_HEIGHT; y++) {
        for (int x = 0; x < MAX_WIDTH; x++) {
            text_buffer[y][x].ch = ' ';
            text_buffer[y][x].fg = COLOR_WHITE;
            text_buffer[y][x].bg = COLOR_BLACK;
            text_buffer[y][x].dirty = 1;
        }
    }
    memset(pixel_buffer, -1, sizeof(pixel_buffer));
}

// Set cursor position (0-based)
void set_cursor_pos(int x, int y) {
#ifdef _WIN32
    COORD coord = { (short)x, (short)y };
    SetConsoleCursorPosition(hConsole, coord);
#else
    printf("\033[%d;%dH", y + 1, x + 1);
#endif
}

// Set color (ANSI 16 colors)
void set_color(Color fg, Color bg) {
    int f = fg < 8 ? 30 + fg : 90 + (fg - 8);
    int b = bg < 8 ? 40 + bg : 100 + (bg - 8);
    printf("\033[%d;%dm", f, b);
}

// Reset color
void reset_color() {
    printf("\033[0m");
}

// Switch to text mode
void set_text_mode() {
    is_bitmap_mode = 0;
    clear_screen();
}

// Switch to bitmap mode
void set_bitmap_mode() {
    is_bitmap_mode = 1;
    clear_screen();
}

// Write text at position in text mode
void write_text(int x, int y, const char *text, Color fg, Color bg) {
    if (is_bitmap_mode || x < 0 || y < 0 || y >= MAX_HEIGHT) return;
    int len = strlen(text);
    for (int i = 0; i < len && x + i < MAX_WIDTH; i++) {
        text_buffer[y][x + i].ch = text[i];
        text_buffer[y][x + i].fg = fg;
        text_buffer[y][x + i].bg = bg;
        text_buffer[y][x + i].dirty = 1;
    }
}

// Set pixel in bitmap mode
void set_pixel(int px, int py, Color color) {
    if (!is_bitmap_mode || px < 0 || py < 0 || px >= MAX_WIDTH || py >= PIXEL_HEIGHT) return;
    pixel_buffer[py][px] = color;
    int ty = py / 2;
    text_buffer[ty][px].dirty = 1;
}

// Read char from text buffer
char read_char(int x, int y) {
    if (x < 0 || y < 0 || y >= MAX_HEIGHT || x >= MAX_WIDTH) return ' ';
    return text_buffer[y][x].ch;
}

// Read pixel from bitmap buffer
int read_pixel(int px, int py) {
    if (px < 0 || py < 0 || px >= MAX_WIDTH || py >= PIXEL_HEIGHT) return -1;
    return pixel_buffer[py][px];
}

// Flush screen buffer to console
void flush_screen() {
    int width, height;
    get_terminal_size(&width, &height);
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            if (text_buffer[y][x].dirty) {
                set_cursor_pos(x, y);
                if (is_bitmap_mode) {
                    int top = pixel_buffer[y * 2][x];
                    int bot = pixel_buffer[y * 2 + 1][x];
                    Color fg = (top >= 0) ? top : COLOR_BLACK;
                    Color bg = (bot >= 0) ? bot : COLOR_BLACK;
                    set_color(fg, bg);
                    if (top >= 0 && bot >= 0) {
                        if (fg == bg) {
                            putchar(' ');
                        } else {
                            putchar('\xdb'); // Full block █
                        }
                    } else if (top >= 0) {
                        putchar('\xdf'); // Upper half ▀
                    } else if (bot >= 0) {
                        putchar('\xdc'); // Lower half ▄
                    } else {
                        putchar(' ');
                    }
                } else {
                    set_color(text_buffer[y][x].fg, text_buffer[y][x].bg);
                    putchar(text_buffer[y][x].ch);
                }
                text_buffer[y][x].dirty = 0;
            }
        }
    }
    reset_color();
    fflush(stdout);
}

// Get terminal size
void get_terminal_size(int *width, int *height) {
#ifdef _WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hConsole, &csbi);
    *width = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    *height = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
#else
    struct winsize ws;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);
    *width = ws.ws_col;
    *height = ws.ws_row;
#endif
    if (*width > MAX_WIDTH) *width = MAX_WIDTH;
    if (*height > MAX_HEIGHT) *height = MAX_HEIGHT;
}

// Draw console box
void draw_box(ConsoleBox *box, Color fg, Color bg) {
    if (is_bitmap_mode) {
        // Draw box in bitmap mode (pixel coordinates)
        int px1 = box->x, py1 = box->y;
        int px2 = box->x + box->width - 1;
        int py2 = box->y + box->height - 1;
        for (int x = px1; x <= px2; x++) {
            set_pixel(x, py1, fg); // Top border
            set_pixel(x, py2, fg); // Bottom border
        }
        for (int y = py1; y <= py2; y++) {
            set_pixel(px1, y, fg); // Left border
            set_pixel(px2, y, fg); // Right border
        }
    } else {
        // Draw box in text mode
        for (int x = box->x; x < box->x + box->width && x < MAX_WIDTH; x++) {
            write_text(x, box->y, "─", fg, bg);
            write_text(x, box->y + box->height - 1, "─", fg, bg);
        }
        for (int y = box->y; y < box->y + box->height && y < MAX_HEIGHT; y++) {
            write_text(box->x, y, "│", fg, bg);
            write_text(box->x + box->width - 1, y, "│", fg, bg);
        }
        write_text(box->x, box->y, "┌", fg, bg);
        write_text(box->x + box->width - 1, box->y, "┐", fg, bg);
        write_text(box->x, box->y + box->height - 1, "└", fg, bg);
        write_text(box->x + box->width - 1, box->y + box->height - 1, "┘", fg, bg);
    }
}

// Check if mouse event is within box
int is_mouse_in_box(MouseEvent *event, ConsoleBox *box) {
    int ex = event->x, ey = event->y;
    if (is_bitmap_mode) {
        return ex >= box->x && ex < box->x + box->width && 
               ey >= box->y && ey < box->y + box->height;
    } else {
        return ex >= box->x && ex < box->x + box->width && 
               ey >= box->y && ey < box->y + box->height;
    }
}

// Get mouse event
int get_mouse_event(MouseEvent *event) {
#ifdef _WIN32
    INPUT_RECORD ir;
    DWORD read;
    if (!PeekConsoleInput(hConsoleIn, &ir, 1, &read) || read == 0) {
        return 0; // No input
    }
    ReadConsoleInput(hConsoleIn, &ir, 1, &read);
    if (ir.EventType == MOUSE_EVENT) {
        MOUSE_EVENT_RECORD mer = ir.Event.MouseEvent;
        event->x = mer.dwMousePosition.X;
        event->y = mer.dwMousePosition.Y;
        event->is_click = (mer.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED) ? 1 : 0;
        event->button = event->is_click ? 1 : 0; // Left button only
        return 1;
    }
#else
    fd_set fds;
    struct timeval tv = {0, 0};
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    if (select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv) <= 0) {
        return 0; // No input
    }
    char buf[32];
    int n = read(STDIN_FILENO, buf, sizeof(buf) - 1);
    if (n <= 0) return 0;
    buf[n] = '\0';
    // Parse ANSI mouse event (SGR format: <ESC>[<;x;yM or m)
    int button, x, y;
    char end_char;
    if (sscanf(buf, "\033[<%d;%d;%d%c", &button, &x, &y, &end_char) == 4) {
        event->x = x - 1; // ANSI is 1-based
        event->y = y - 1;
        event->is_click = (end_char == 'M'); // M=press, m=release
        event->button = (button == 0) ? 1 : (button == 2) ? 2 : 0; // Left=0, Right=2
        return 1;
    }
#endif
    return 0;
}

// Example usage
int main() {
    init_console();

    // Define a box
    ConsoleBox box = {10, 5, 20, 10}; // x=10, y=5, w=20, h=10

    // Test in text mode
    set_text_mode();
    draw_box(&box, COLOR_YELLOW, COLOR_BLACK);
    write_text(box.x + 2, box.y + 2, "Click in box!", COLOR_GREEN, COLOR_BLACK);
    flush_screen();

    MouseEvent event;
    while (1) {
        if (get_mouse_event(&event)) {
            if (is_mouse_in_box(&event, &box)) {
                if (event.is_click && event.button == 1) {
                    write_text(box.x + 2, box.y + 4, "Left Click!  ", COLOR_RED, COLOR_BLACK);
                } else {
                    char pos[32];
                    snprintf(pos, sizeof(pos), "Mouse at %2d,%2d", event.x, event.y);
                    write_text(box.x + 2, box.y + 5, pos, COLOR_CYAN, COLOR_BLACK);
                }
                flush_screen();
            }
        }
        // Check for exit (press 'q')
        if (kbhit()) {
            if (getch() == 'q') break;
        }
    }

    // Test in bitmap mode
    set_bitmap_mode();
    draw_box(&box, COLOR_YELLOW, COLOR_BLACK);
    flush_screen();

    while (1) {
        if (get_mouse_event(&event)) {
            if (is_mouse_in_box(&event, &box)) {
                if (event.is_click && event.button == 1) {
                    set_pixel(event.x, event.y, COLOR_RED);
                } else {
                    set_pixel(event.x, event.y, COLOR_CYAN);
                }
                flush_screen();
            }
        }
        if (kbhit()) {
            if (getch() == 'q') break;
        }
    }

    cleanup_console();
    return 0;
}
</xaiArtifact>

